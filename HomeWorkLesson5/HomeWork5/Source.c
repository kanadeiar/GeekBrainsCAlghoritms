#include <windows.h>
#include <stdio.h>

#include "Header.h"
#include "Task1.h"
#include "Task2.h"
#include "Task3.h"
#include "Task4.h"
#include "Task5.h"
#include "Task6.h"

/*
 * Курс "Алгоритмы и структуры данных. Базовый курс."
 * Урок 5. Динамические структуры данных
 * Задачи
 * Рассахатский
 */
int main(int argc, char * args[])
{
    Ru();
	PrintHeader();
	/////////////////////////////////////////////
	int userSelect = 0;
	do
	{
		PrintMenu();
		scanf_s(" %d", &userSelect);
		getchar();
		actionSelect(userSelect);
	}
	while (userSelect != 0);
	//////////////////////////////////////////////
	PrintFooter();
	return 0;
}

void Task1Binary()
{
	printf("\n**************************************************************************************\n");
	printf("1. Реализовать перевод из десятичной в двоичную систему счисления с использованием стека.\n");
	/////////////////////////////////////////////////////////////
	printf("Введите целое число в десятичной системе счисления:> ");
	int decnum;
	scanf_s(" %d", &decnum);
	getchar();
	long longval = getBinFromDec(10);
	printf("Это-же значение в десятичной системе счисления: %d", longval);
	//////////////////////////////////////////////
	getchar();
}

void Task2Stack()
{
	printf("\n**************************************************************************************\n");
	printf("2. Добавить в программу \"Реализация стека на основе односвязного списка\" проверку на выделение памяти.\nЕсли память не выделяется, то выводится соответствующее сообщение.\n");
	/////////////////////////////////////////////////////////////
	Stack.maxSize = 100;
	Stack.head = NULL;
	Push('a');
	Push('b');
	Push('c');
	PrintStack();
	//////////////////////////////////////////////
	getchar();
}

void Task3GoodSequence()
{
	printf("\n**************************************************************************************\n");
	printf("3. Написать программу, которая определяет, является ли введенная скобочная последовательность правильной. Примеры правильных скобочных \nвыражений: (), ([])(), {}(),([{}]), \nнеправильных — )(, ())({), (, ])}), ([(]) \nдля скобок [, (, {.\nНапример: (2+(2*2)) или [2/{5*(4+7)}]..\n");
	/////////////////////////////////////////////////////////////
	printf("Введите последовательность символов:> ");
	char str[255];
	gets_s(str, _countof(str));
	int res = isGoodSequence(str);
	printf("Эта последовательность%s правильная.\n", res ? "" : " не");
	//////////////////////////////////////////////
	getchar();
}

void Task4CopyList()
{
	printf("\n**************************************************************************************\n");
	printf("4. Создать функцию, копирующую односвязный список (то есть создающую в памяти копию односвязного списка без удаления первого списка).\n");
	/////////////////////////////////////////////////////////////
	struct My_Node * head = InitMyNodes(1);
	AddToEndMyNodes(head, 2);
	AddToEndMyNodes(head, 3);
	AddToEndMyNodes(head, 4);
	AddToEndMyNodes(head, 5);
	puts("Первый список:");
	PrintNodes(head);
	struct My_Node * headTwo = CloneMyNodes(head);
	puts("Второй склонированный список:");
	PrintNodes(headTwo);	
	//////////////////////////////////////////////
	getchar();
}

void Task5InfixToPostfix()
{
	printf("\n**************************************************************************************\n");
	printf("5. **Реализовать алгоритм перевода из инфиксной записи арифметического выражения в постфиксную.\n");
	/////////////////////////////////////////////////////////////
	char str[128] = "(6+2)*3";
	printf("Исходное выражение: %s\n", str);
	char str2[128];
	InfixPostfix(str, str2);
	printf("Результат преобразования: = %s\n", str2);
	//////////////////////////////////////////////
	getchar();
}

void Task6Queue()
{
	printf("\n**************************************************************************************\n");
	printf("6. *Реализовать очередь.\n");
	/////////////////////////////////////////////////////////////
	Queue.maxSize = 100;
	Enqueue('a');
	Enqueue('b');
	Enqueue('c');
	puts("Содержимое очереди:");
	while (Queue.size != 0)
	{
		printf("%c\n", Dequeue());
	}
	puts("Дополнительно:");
	Dequeue();
	Enqueue('1');
	Enqueue('2');
	Enqueue('3');
	puts("Содержимое очереди теперь:");
	while (Queue.size != 0)
	{
		printf("%c\n", Dequeue());
	}
	//////////////////////////////////////////////
	getchar();}
